import { Submission } from '../types';
import { supabase } from './supabaseClient';

const QUEUE_KEY = 'offline_submission_queue';

/**
 * Adds a submission to the local offline queue.
 * This guarantees no data loss even if the network is down.
 */
export const enqueueSubmission = (submission: Submission) => {
  try {
    const currentQueue = getQueue();
    // Avoid duplicates if possible
    if (!currentQueue.some(s => s.id === submission.id)) {
      currentQueue.push(submission);
      saveQueue(currentQueue);
      console.log(`ðŸ“¥ Queued submission: ${submission.studentName}`);
    }

    // Trigger immediate sync attempt if online
    if (navigator.onLine) {
      processQueue();
    }
  } catch (e) {
    console.error("Queue Error:", e);
  }
};

/**
 * Retrieves current queue from LocalStorage
 */
const getQueue = (): Submission[] => {
  try {
    const stored = localStorage.getItem(QUEUE_KEY);
    return stored ? JSON.parse(stored) : [];
  } catch {
    return [];
  }
};

/**
 * Saves queue to LocalStorage
 */
const saveQueue = (queue: Submission[]) => {
  localStorage.setItem(QUEUE_KEY, JSON.stringify(queue));
};

let isSyncing = false;

/**
 * Attempts to send queued submissions to Supabase.
 * Removes them from the queue only upon successful confirmation.
 */
export const processQueue = async () => {
  if (isSyncing || !supabase) return;

  // 1. Snapshot the queue at the start of the process
  const batchToSync = getQueue();
  if (batchToSync.length === 0) return;

  isSyncing = true;

  try {
    console.log(`ðŸ”„ Syncing ${batchToSync.length} records to Supabase...`);

    // SECURITY UPDATE:
    // We previously used 'upsert'. However, with hardened RLS policies,
    // anonymous users can only INSERT, not UPDATE.
    // 'upsert' tries to update on conflict, which would now fail with "Access Denied".
    // We switch to 'insert' with explicit ignoreDuplicates behavior (if Supabase supports it via options)
    // or we handle the error.

    // Since our IDs are UUIDs generated by the client, conflicts *should* be rare unless a retry happens.
    // If a conflict happens (Record already exists), it means it was already synced.

    // Attempt standard insert.
    // NOTE: 'ignoreDuplicates: true' is supported in the JS client for insert()
    const { error } = await supabase
      .from('submissions')
      .insert(batchToSync)
      .select('id'); // Minimal select to verify success if needed

    if (error) {
       // If the error is a Duplicate Key error (Code 23505), we can consider it "Synced"
       // But 'insert' with a batch might fail the whole batch if one fails?
       // Let's use upsert() BUT with ignoreDuplicates: true, which is effectively "Insert if not exists".
       // IMPORTANT: For 'upsert' to work with RLS 'INSERT-ONLY' policy, the conflict resolution must not trigger an UPDATE.
       // The supabase client 'ignoreDuplicates: true' option prevents the UPDATE action on conflict.

       const { error: retryError } = await supabase
        .from('submissions')
        .upsert(batchToSync, { onConflict: 'id', ignoreDuplicates: true });

       if (retryError) {
          console.error('âŒ Supabase Sync Error:', retryError);
       } else {
          // Success on retry path
          markBatchAsSynced(batchToSync);
       }
    } else {
      // Success on first try
      markBatchAsSynced(batchToSync);
    }

  } catch (err) {
    console.error('âŒ Sync Exception:', err);
  } finally {
    isSyncing = false;
  }
};

const markBatchAsSynced = (batch: Submission[]) => {
      console.log(`âœ… Successfully synced ${batch.length} records!`);

      // 2. Remove ONLY the items we successfully synced.
      const currentQueue = getQueue();
      const syncedIds = new Set(batch.map(s => s.id));

      const remainingQueue = currentQueue.filter(item => !syncedIds.has(item.id));
      saveQueue(remainingQueue);
};

/**
 * Starts the background sync process.
 * Call this once when the app mounts.
 * Returns a cleanup function.
 */
export const startQueueSync = (intervalMs = 10000) => {
  // Run on startup
  processQueue();

  // Set up interval
  const intervalId = setInterval(() => {
    if (navigator.onLine) {
      processQueue();
    }
  }, intervalMs);

  const handleOnline = () => {
    console.log("ðŸŒ Back online! Syncing...");
    processQueue();
  };

  // Also listen for online status
  window.addEventListener('online', handleOnline);

  // Return cleanup function
  return () => {
    clearInterval(intervalId);
    window.removeEventListener('online', handleOnline);
  };
};
